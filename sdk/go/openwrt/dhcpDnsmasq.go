// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package openwrt

import (
	"context"
	"reflect"

	"github.com/deposition-cloud/pulumi-openwrt/sdk/go/openwrt/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
)

// A lightweight DHCP and caching DNS server.
//
// ## Import
//
// Find the Terraform id from LuCI's JSON-RPC API. One way to find this information is with `curl` and `jq`# curl \
//
//	--data '{"id"0, "method""foreach", "params"["dhcp", "dnsmasq"]}' \
//
//	http://192.168.1.1/cgi-bin/luci/rpc/uci?auth=$AUTH_TOKEN \
//
//	| jq '.result | map({terraformId.[".name"]})' # This command will output something like# [
//
//	{
//
//	"terraformId""cfg123456",
//
//	} ] # We'd then use the information to import the appropriate resource
//
// ```sh
//
//	$ pulumi import openwrt:index/dhcpDnsmasq:DhcpDnsmasq this cfg123456
//
// ```
type DhcpDnsmasq struct {
	pulumi.CustomResourceState

	// Force dnsmasq into authoritative mode. This speeds up DHCP leasing. Used if this is the only server on the network.
	Authoritative pulumi.BoolOutput `pulumi:"authoritative"`
	// DNS domain handed out to DHCP clients.
	Domain pulumi.StringOutput `pulumi:"domain"`
	// Never forward queries for plain names, without dots or domain parts, to upstream nameservers.
	Domainneeded pulumi.BoolOutput `pulumi:"domainneeded"`
	// Specify the largest EDNS.0 UDP packet which is supported by the DNS forwarder.
	EdnspacketMax pulumi.IntOutput `pulumi:"ednspacketMax"`
	// Never forward queries for plain names, without dots or domain parts, to upstream nameservers.
	Expandhosts pulumi.BoolOutput `pulumi:"expandhosts"`
	// Store DHCP leases in this file.
	Leasefile pulumi.StringOutput `pulumi:"leasefile"`
	// Look up DNS entries for this domain from `/etc/hosts`.
	Local pulumi.StringOutput `pulumi:"local"`
	// Choose IP address to match the incoming interface if multiple addresses are assigned to a host name in `/etc/hosts`.
	LocaliseQueries pulumi.BoolOutput `pulumi:"localiseQueries"`
	// Accept DNS queries only from hosts whose address is on a local subnet.
	Localservice pulumi.BoolOutput `pulumi:"localservice"`
	// Read static lease entries from `/etc/ethers`, re-read on SIGHUP.
	Readethers pulumi.BoolOutput `pulumi:"readethers"`
	// Allows upstream 127.0.0.0/8 responses, required for DNS based blocklist services. Only takes effect if rebind protection is enabled.
	RebindLocalhost pulumi.BoolOutput `pulumi:"rebindLocalhost"`
	// Enables DNS rebind attack protection by discarding upstream RFC1918 responses.
	RebindProtection pulumi.BoolOutput `pulumi:"rebindProtection"`
	// Specifies an alternative resolv file.
	Resolvfile pulumi.StringOutput `pulumi:"resolvfile"`
}

// NewDhcpDnsmasq registers a new resource with the given unique name, arguments, and options.
func NewDhcpDnsmasq(ctx *pulumi.Context,
	name string, args *DhcpDnsmasqArgs, opts ...pulumi.ResourceOption) (*DhcpDnsmasq, error) {
	if args == nil {
		args = &DhcpDnsmasqArgs{}
	}

	opts = internal.PkgResourceDefaultOpts(opts)
	var resource DhcpDnsmasq
	err := ctx.RegisterResource("openwrt:index/dhcpDnsmasq:DhcpDnsmasq", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetDhcpDnsmasq gets an existing DhcpDnsmasq resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetDhcpDnsmasq(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *DhcpDnsmasqState, opts ...pulumi.ResourceOption) (*DhcpDnsmasq, error) {
	var resource DhcpDnsmasq
	err := ctx.ReadResource("openwrt:index/dhcpDnsmasq:DhcpDnsmasq", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering DhcpDnsmasq resources.
type dhcpDnsmasqState struct {
	// Force dnsmasq into authoritative mode. This speeds up DHCP leasing. Used if this is the only server on the network.
	Authoritative *bool `pulumi:"authoritative"`
	// DNS domain handed out to DHCP clients.
	Domain *string `pulumi:"domain"`
	// Never forward queries for plain names, without dots or domain parts, to upstream nameservers.
	Domainneeded *bool `pulumi:"domainneeded"`
	// Specify the largest EDNS.0 UDP packet which is supported by the DNS forwarder.
	EdnspacketMax *int `pulumi:"ednspacketMax"`
	// Never forward queries for plain names, without dots or domain parts, to upstream nameservers.
	Expandhosts *bool `pulumi:"expandhosts"`
	// Store DHCP leases in this file.
	Leasefile *string `pulumi:"leasefile"`
	// Look up DNS entries for this domain from `/etc/hosts`.
	Local *string `pulumi:"local"`
	// Choose IP address to match the incoming interface if multiple addresses are assigned to a host name in `/etc/hosts`.
	LocaliseQueries *bool `pulumi:"localiseQueries"`
	// Accept DNS queries only from hosts whose address is on a local subnet.
	Localservice *bool `pulumi:"localservice"`
	// Read static lease entries from `/etc/ethers`, re-read on SIGHUP.
	Readethers *bool `pulumi:"readethers"`
	// Allows upstream 127.0.0.0/8 responses, required for DNS based blocklist services. Only takes effect if rebind protection is enabled.
	RebindLocalhost *bool `pulumi:"rebindLocalhost"`
	// Enables DNS rebind attack protection by discarding upstream RFC1918 responses.
	RebindProtection *bool `pulumi:"rebindProtection"`
	// Specifies an alternative resolv file.
	Resolvfile *string `pulumi:"resolvfile"`
}

type DhcpDnsmasqState struct {
	// Force dnsmasq into authoritative mode. This speeds up DHCP leasing. Used if this is the only server on the network.
	Authoritative pulumi.BoolPtrInput
	// DNS domain handed out to DHCP clients.
	Domain pulumi.StringPtrInput
	// Never forward queries for plain names, without dots or domain parts, to upstream nameservers.
	Domainneeded pulumi.BoolPtrInput
	// Specify the largest EDNS.0 UDP packet which is supported by the DNS forwarder.
	EdnspacketMax pulumi.IntPtrInput
	// Never forward queries for plain names, without dots or domain parts, to upstream nameservers.
	Expandhosts pulumi.BoolPtrInput
	// Store DHCP leases in this file.
	Leasefile pulumi.StringPtrInput
	// Look up DNS entries for this domain from `/etc/hosts`.
	Local pulumi.StringPtrInput
	// Choose IP address to match the incoming interface if multiple addresses are assigned to a host name in `/etc/hosts`.
	LocaliseQueries pulumi.BoolPtrInput
	// Accept DNS queries only from hosts whose address is on a local subnet.
	Localservice pulumi.BoolPtrInput
	// Read static lease entries from `/etc/ethers`, re-read on SIGHUP.
	Readethers pulumi.BoolPtrInput
	// Allows upstream 127.0.0.0/8 responses, required for DNS based blocklist services. Only takes effect if rebind protection is enabled.
	RebindLocalhost pulumi.BoolPtrInput
	// Enables DNS rebind attack protection by discarding upstream RFC1918 responses.
	RebindProtection pulumi.BoolPtrInput
	// Specifies an alternative resolv file.
	Resolvfile pulumi.StringPtrInput
}

func (DhcpDnsmasqState) ElementType() reflect.Type {
	return reflect.TypeOf((*dhcpDnsmasqState)(nil)).Elem()
}

type dhcpDnsmasqArgs struct {
	// Force dnsmasq into authoritative mode. This speeds up DHCP leasing. Used if this is the only server on the network.
	Authoritative *bool `pulumi:"authoritative"`
	// DNS domain handed out to DHCP clients.
	Domain *string `pulumi:"domain"`
	// Never forward queries for plain names, without dots or domain parts, to upstream nameservers.
	Domainneeded *bool `pulumi:"domainneeded"`
	// Specify the largest EDNS.0 UDP packet which is supported by the DNS forwarder.
	EdnspacketMax *int `pulumi:"ednspacketMax"`
	// Never forward queries for plain names, without dots or domain parts, to upstream nameservers.
	Expandhosts *bool `pulumi:"expandhosts"`
	// Store DHCP leases in this file.
	Leasefile *string `pulumi:"leasefile"`
	// Look up DNS entries for this domain from `/etc/hosts`.
	Local *string `pulumi:"local"`
	// Choose IP address to match the incoming interface if multiple addresses are assigned to a host name in `/etc/hosts`.
	LocaliseQueries *bool `pulumi:"localiseQueries"`
	// Accept DNS queries only from hosts whose address is on a local subnet.
	Localservice *bool `pulumi:"localservice"`
	// Read static lease entries from `/etc/ethers`, re-read on SIGHUP.
	Readethers *bool `pulumi:"readethers"`
	// Allows upstream 127.0.0.0/8 responses, required for DNS based blocklist services. Only takes effect if rebind protection is enabled.
	RebindLocalhost *bool `pulumi:"rebindLocalhost"`
	// Enables DNS rebind attack protection by discarding upstream RFC1918 responses.
	RebindProtection *bool `pulumi:"rebindProtection"`
	// Specifies an alternative resolv file.
	Resolvfile *string `pulumi:"resolvfile"`
}

// The set of arguments for constructing a DhcpDnsmasq resource.
type DhcpDnsmasqArgs struct {
	// Force dnsmasq into authoritative mode. This speeds up DHCP leasing. Used if this is the only server on the network.
	Authoritative pulumi.BoolPtrInput
	// DNS domain handed out to DHCP clients.
	Domain pulumi.StringPtrInput
	// Never forward queries for plain names, without dots or domain parts, to upstream nameservers.
	Domainneeded pulumi.BoolPtrInput
	// Specify the largest EDNS.0 UDP packet which is supported by the DNS forwarder.
	EdnspacketMax pulumi.IntPtrInput
	// Never forward queries for plain names, without dots or domain parts, to upstream nameservers.
	Expandhosts pulumi.BoolPtrInput
	// Store DHCP leases in this file.
	Leasefile pulumi.StringPtrInput
	// Look up DNS entries for this domain from `/etc/hosts`.
	Local pulumi.StringPtrInput
	// Choose IP address to match the incoming interface if multiple addresses are assigned to a host name in `/etc/hosts`.
	LocaliseQueries pulumi.BoolPtrInput
	// Accept DNS queries only from hosts whose address is on a local subnet.
	Localservice pulumi.BoolPtrInput
	// Read static lease entries from `/etc/ethers`, re-read on SIGHUP.
	Readethers pulumi.BoolPtrInput
	// Allows upstream 127.0.0.0/8 responses, required for DNS based blocklist services. Only takes effect if rebind protection is enabled.
	RebindLocalhost pulumi.BoolPtrInput
	// Enables DNS rebind attack protection by discarding upstream RFC1918 responses.
	RebindProtection pulumi.BoolPtrInput
	// Specifies an alternative resolv file.
	Resolvfile pulumi.StringPtrInput
}

func (DhcpDnsmasqArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*dhcpDnsmasqArgs)(nil)).Elem()
}

type DhcpDnsmasqInput interface {
	pulumi.Input

	ToDhcpDnsmasqOutput() DhcpDnsmasqOutput
	ToDhcpDnsmasqOutputWithContext(ctx context.Context) DhcpDnsmasqOutput
}

func (*DhcpDnsmasq) ElementType() reflect.Type {
	return reflect.TypeOf((**DhcpDnsmasq)(nil)).Elem()
}

func (i *DhcpDnsmasq) ToDhcpDnsmasqOutput() DhcpDnsmasqOutput {
	return i.ToDhcpDnsmasqOutputWithContext(context.Background())
}

func (i *DhcpDnsmasq) ToDhcpDnsmasqOutputWithContext(ctx context.Context) DhcpDnsmasqOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DhcpDnsmasqOutput)
}

func (i *DhcpDnsmasq) ToOutput(ctx context.Context) pulumix.Output[*DhcpDnsmasq] {
	return pulumix.Output[*DhcpDnsmasq]{
		OutputState: i.ToDhcpDnsmasqOutputWithContext(ctx).OutputState,
	}
}

// DhcpDnsmasqArrayInput is an input type that accepts DhcpDnsmasqArray and DhcpDnsmasqArrayOutput values.
// You can construct a concrete instance of `DhcpDnsmasqArrayInput` via:
//
//	DhcpDnsmasqArray{ DhcpDnsmasqArgs{...} }
type DhcpDnsmasqArrayInput interface {
	pulumi.Input

	ToDhcpDnsmasqArrayOutput() DhcpDnsmasqArrayOutput
	ToDhcpDnsmasqArrayOutputWithContext(context.Context) DhcpDnsmasqArrayOutput
}

type DhcpDnsmasqArray []DhcpDnsmasqInput

func (DhcpDnsmasqArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*DhcpDnsmasq)(nil)).Elem()
}

func (i DhcpDnsmasqArray) ToDhcpDnsmasqArrayOutput() DhcpDnsmasqArrayOutput {
	return i.ToDhcpDnsmasqArrayOutputWithContext(context.Background())
}

func (i DhcpDnsmasqArray) ToDhcpDnsmasqArrayOutputWithContext(ctx context.Context) DhcpDnsmasqArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DhcpDnsmasqArrayOutput)
}

func (i DhcpDnsmasqArray) ToOutput(ctx context.Context) pulumix.Output[[]*DhcpDnsmasq] {
	return pulumix.Output[[]*DhcpDnsmasq]{
		OutputState: i.ToDhcpDnsmasqArrayOutputWithContext(ctx).OutputState,
	}
}

// DhcpDnsmasqMapInput is an input type that accepts DhcpDnsmasqMap and DhcpDnsmasqMapOutput values.
// You can construct a concrete instance of `DhcpDnsmasqMapInput` via:
//
//	DhcpDnsmasqMap{ "key": DhcpDnsmasqArgs{...} }
type DhcpDnsmasqMapInput interface {
	pulumi.Input

	ToDhcpDnsmasqMapOutput() DhcpDnsmasqMapOutput
	ToDhcpDnsmasqMapOutputWithContext(context.Context) DhcpDnsmasqMapOutput
}

type DhcpDnsmasqMap map[string]DhcpDnsmasqInput

func (DhcpDnsmasqMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*DhcpDnsmasq)(nil)).Elem()
}

func (i DhcpDnsmasqMap) ToDhcpDnsmasqMapOutput() DhcpDnsmasqMapOutput {
	return i.ToDhcpDnsmasqMapOutputWithContext(context.Background())
}

func (i DhcpDnsmasqMap) ToDhcpDnsmasqMapOutputWithContext(ctx context.Context) DhcpDnsmasqMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DhcpDnsmasqMapOutput)
}

func (i DhcpDnsmasqMap) ToOutput(ctx context.Context) pulumix.Output[map[string]*DhcpDnsmasq] {
	return pulumix.Output[map[string]*DhcpDnsmasq]{
		OutputState: i.ToDhcpDnsmasqMapOutputWithContext(ctx).OutputState,
	}
}

type DhcpDnsmasqOutput struct{ *pulumi.OutputState }

func (DhcpDnsmasqOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DhcpDnsmasq)(nil)).Elem()
}

func (o DhcpDnsmasqOutput) ToDhcpDnsmasqOutput() DhcpDnsmasqOutput {
	return o
}

func (o DhcpDnsmasqOutput) ToDhcpDnsmasqOutputWithContext(ctx context.Context) DhcpDnsmasqOutput {
	return o
}

func (o DhcpDnsmasqOutput) ToOutput(ctx context.Context) pulumix.Output[*DhcpDnsmasq] {
	return pulumix.Output[*DhcpDnsmasq]{
		OutputState: o.OutputState,
	}
}

// Force dnsmasq into authoritative mode. This speeds up DHCP leasing. Used if this is the only server on the network.
func (o DhcpDnsmasqOutput) Authoritative() pulumi.BoolOutput {
	return o.ApplyT(func(v *DhcpDnsmasq) pulumi.BoolOutput { return v.Authoritative }).(pulumi.BoolOutput)
}

// DNS domain handed out to DHCP clients.
func (o DhcpDnsmasqOutput) Domain() pulumi.StringOutput {
	return o.ApplyT(func(v *DhcpDnsmasq) pulumi.StringOutput { return v.Domain }).(pulumi.StringOutput)
}

// Never forward queries for plain names, without dots or domain parts, to upstream nameservers.
func (o DhcpDnsmasqOutput) Domainneeded() pulumi.BoolOutput {
	return o.ApplyT(func(v *DhcpDnsmasq) pulumi.BoolOutput { return v.Domainneeded }).(pulumi.BoolOutput)
}

// Specify the largest EDNS.0 UDP packet which is supported by the DNS forwarder.
func (o DhcpDnsmasqOutput) EdnspacketMax() pulumi.IntOutput {
	return o.ApplyT(func(v *DhcpDnsmasq) pulumi.IntOutput { return v.EdnspacketMax }).(pulumi.IntOutput)
}

// Never forward queries for plain names, without dots or domain parts, to upstream nameservers.
func (o DhcpDnsmasqOutput) Expandhosts() pulumi.BoolOutput {
	return o.ApplyT(func(v *DhcpDnsmasq) pulumi.BoolOutput { return v.Expandhosts }).(pulumi.BoolOutput)
}

// Store DHCP leases in this file.
func (o DhcpDnsmasqOutput) Leasefile() pulumi.StringOutput {
	return o.ApplyT(func(v *DhcpDnsmasq) pulumi.StringOutput { return v.Leasefile }).(pulumi.StringOutput)
}

// Look up DNS entries for this domain from `/etc/hosts`.
func (o DhcpDnsmasqOutput) Local() pulumi.StringOutput {
	return o.ApplyT(func(v *DhcpDnsmasq) pulumi.StringOutput { return v.Local }).(pulumi.StringOutput)
}

// Choose IP address to match the incoming interface if multiple addresses are assigned to a host name in `/etc/hosts`.
func (o DhcpDnsmasqOutput) LocaliseQueries() pulumi.BoolOutput {
	return o.ApplyT(func(v *DhcpDnsmasq) pulumi.BoolOutput { return v.LocaliseQueries }).(pulumi.BoolOutput)
}

// Accept DNS queries only from hosts whose address is on a local subnet.
func (o DhcpDnsmasqOutput) Localservice() pulumi.BoolOutput {
	return o.ApplyT(func(v *DhcpDnsmasq) pulumi.BoolOutput { return v.Localservice }).(pulumi.BoolOutput)
}

// Read static lease entries from `/etc/ethers`, re-read on SIGHUP.
func (o DhcpDnsmasqOutput) Readethers() pulumi.BoolOutput {
	return o.ApplyT(func(v *DhcpDnsmasq) pulumi.BoolOutput { return v.Readethers }).(pulumi.BoolOutput)
}

// Allows upstream 127.0.0.0/8 responses, required for DNS based blocklist services. Only takes effect if rebind protection is enabled.
func (o DhcpDnsmasqOutput) RebindLocalhost() pulumi.BoolOutput {
	return o.ApplyT(func(v *DhcpDnsmasq) pulumi.BoolOutput { return v.RebindLocalhost }).(pulumi.BoolOutput)
}

// Enables DNS rebind attack protection by discarding upstream RFC1918 responses.
func (o DhcpDnsmasqOutput) RebindProtection() pulumi.BoolOutput {
	return o.ApplyT(func(v *DhcpDnsmasq) pulumi.BoolOutput { return v.RebindProtection }).(pulumi.BoolOutput)
}

// Specifies an alternative resolv file.
func (o DhcpDnsmasqOutput) Resolvfile() pulumi.StringOutput {
	return o.ApplyT(func(v *DhcpDnsmasq) pulumi.StringOutput { return v.Resolvfile }).(pulumi.StringOutput)
}

type DhcpDnsmasqArrayOutput struct{ *pulumi.OutputState }

func (DhcpDnsmasqArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*DhcpDnsmasq)(nil)).Elem()
}

func (o DhcpDnsmasqArrayOutput) ToDhcpDnsmasqArrayOutput() DhcpDnsmasqArrayOutput {
	return o
}

func (o DhcpDnsmasqArrayOutput) ToDhcpDnsmasqArrayOutputWithContext(ctx context.Context) DhcpDnsmasqArrayOutput {
	return o
}

func (o DhcpDnsmasqArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]*DhcpDnsmasq] {
	return pulumix.Output[[]*DhcpDnsmasq]{
		OutputState: o.OutputState,
	}
}

func (o DhcpDnsmasqArrayOutput) Index(i pulumi.IntInput) DhcpDnsmasqOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *DhcpDnsmasq {
		return vs[0].([]*DhcpDnsmasq)[vs[1].(int)]
	}).(DhcpDnsmasqOutput)
}

type DhcpDnsmasqMapOutput struct{ *pulumi.OutputState }

func (DhcpDnsmasqMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*DhcpDnsmasq)(nil)).Elem()
}

func (o DhcpDnsmasqMapOutput) ToDhcpDnsmasqMapOutput() DhcpDnsmasqMapOutput {
	return o
}

func (o DhcpDnsmasqMapOutput) ToDhcpDnsmasqMapOutputWithContext(ctx context.Context) DhcpDnsmasqMapOutput {
	return o
}

func (o DhcpDnsmasqMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]*DhcpDnsmasq] {
	return pulumix.Output[map[string]*DhcpDnsmasq]{
		OutputState: o.OutputState,
	}
}

func (o DhcpDnsmasqMapOutput) MapIndex(k pulumi.StringInput) DhcpDnsmasqOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *DhcpDnsmasq {
		return vs[0].(map[string]*DhcpDnsmasq)[vs[1].(string)]
	}).(DhcpDnsmasqOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*DhcpDnsmasqInput)(nil)).Elem(), &DhcpDnsmasq{})
	pulumi.RegisterInputType(reflect.TypeOf((*DhcpDnsmasqArrayInput)(nil)).Elem(), DhcpDnsmasqArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DhcpDnsmasqMapInput)(nil)).Elem(), DhcpDnsmasqMap{})
	pulumi.RegisterOutputType(DhcpDnsmasqOutput{})
	pulumi.RegisterOutputType(DhcpDnsmasqArrayOutput{})
	pulumi.RegisterOutputType(DhcpDnsmasqMapOutput{})
}
