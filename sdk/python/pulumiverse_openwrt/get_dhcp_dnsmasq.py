# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities

__all__ = [
    'GetDhcpDnsmasqResult',
    'AwaitableGetDhcpDnsmasqResult',
    'get_dhcp_dnsmasq',
    'get_dhcp_dnsmasq_output',
]

@pulumi.output_type
class GetDhcpDnsmasqResult:
    """
    A collection of values returned by getDhcpDnsmasq.
    """
    def __init__(__self__, authoritative=None, domain=None, domainneeded=None, ednspacket_max=None, expandhosts=None, id=None, leasefile=None, local=None, localise_queries=None, localservice=None, readethers=None, rebind_localhost=None, rebind_protection=None, resolvfile=None):
        if authoritative and not isinstance(authoritative, bool):
            raise TypeError("Expected argument 'authoritative' to be a bool")
        pulumi.set(__self__, "authoritative", authoritative)
        if domain and not isinstance(domain, str):
            raise TypeError("Expected argument 'domain' to be a str")
        pulumi.set(__self__, "domain", domain)
        if domainneeded and not isinstance(domainneeded, bool):
            raise TypeError("Expected argument 'domainneeded' to be a bool")
        pulumi.set(__self__, "domainneeded", domainneeded)
        if ednspacket_max and not isinstance(ednspacket_max, int):
            raise TypeError("Expected argument 'ednspacket_max' to be a int")
        pulumi.set(__self__, "ednspacket_max", ednspacket_max)
        if expandhosts and not isinstance(expandhosts, bool):
            raise TypeError("Expected argument 'expandhosts' to be a bool")
        pulumi.set(__self__, "expandhosts", expandhosts)
        if id and not isinstance(id, str):
            raise TypeError("Expected argument 'id' to be a str")
        pulumi.set(__self__, "id", id)
        if leasefile and not isinstance(leasefile, str):
            raise TypeError("Expected argument 'leasefile' to be a str")
        pulumi.set(__self__, "leasefile", leasefile)
        if local and not isinstance(local, str):
            raise TypeError("Expected argument 'local' to be a str")
        pulumi.set(__self__, "local", local)
        if localise_queries and not isinstance(localise_queries, bool):
            raise TypeError("Expected argument 'localise_queries' to be a bool")
        pulumi.set(__self__, "localise_queries", localise_queries)
        if localservice and not isinstance(localservice, bool):
            raise TypeError("Expected argument 'localservice' to be a bool")
        pulumi.set(__self__, "localservice", localservice)
        if readethers and not isinstance(readethers, bool):
            raise TypeError("Expected argument 'readethers' to be a bool")
        pulumi.set(__self__, "readethers", readethers)
        if rebind_localhost and not isinstance(rebind_localhost, bool):
            raise TypeError("Expected argument 'rebind_localhost' to be a bool")
        pulumi.set(__self__, "rebind_localhost", rebind_localhost)
        if rebind_protection and not isinstance(rebind_protection, bool):
            raise TypeError("Expected argument 'rebind_protection' to be a bool")
        pulumi.set(__self__, "rebind_protection", rebind_protection)
        if resolvfile and not isinstance(resolvfile, str):
            raise TypeError("Expected argument 'resolvfile' to be a str")
        pulumi.set(__self__, "resolvfile", resolvfile)

    @property
    @pulumi.getter
    def authoritative(self) -> bool:
        """
        Force dnsmasq into authoritative mode. This speeds up DHCP leasing. Used if this is the only server on the network.
        """
        return pulumi.get(self, "authoritative")

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        DNS domain handed out to DHCP clients.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def domainneeded(self) -> bool:
        """
        Never forward queries for plain names, without dots or domain parts, to upstream nameservers.
        """
        return pulumi.get(self, "domainneeded")

    @property
    @pulumi.getter(name="ednspacketMax")
    def ednspacket_max(self) -> int:
        """
        Specify the largest EDNS.0 UDP packet which is supported by the DNS forwarder.
        """
        return pulumi.get(self, "ednspacket_max")

    @property
    @pulumi.getter
    def expandhosts(self) -> bool:
        """
        Never forward queries for plain names, without dots or domain parts, to upstream nameservers.
        """
        return pulumi.get(self, "expandhosts")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Name of the section. This name is only used when interacting with UCI directly.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def leasefile(self) -> str:
        """
        Store DHCP leases in this file.
        """
        return pulumi.get(self, "leasefile")

    @property
    @pulumi.getter
    def local(self) -> str:
        """
        Look up DNS entries for this domain from `/etc/hosts`.
        """
        return pulumi.get(self, "local")

    @property
    @pulumi.getter(name="localiseQueries")
    def localise_queries(self) -> bool:
        """
        Choose IP address to match the incoming interface if multiple addresses are assigned to a host name in `/etc/hosts`.
        """
        return pulumi.get(self, "localise_queries")

    @property
    @pulumi.getter
    def localservice(self) -> bool:
        """
        Accept DNS queries only from hosts whose address is on a local subnet.
        """
        return pulumi.get(self, "localservice")

    @property
    @pulumi.getter
    def readethers(self) -> bool:
        """
        Read static lease entries from `/etc/ethers`, re-read on SIGHUP.
        """
        return pulumi.get(self, "readethers")

    @property
    @pulumi.getter(name="rebindLocalhost")
    def rebind_localhost(self) -> bool:
        """
        Allows upstream 127.0.0.0/8 responses, required for DNS based blocklist services. Only takes effect if rebind protection is enabled.
        """
        return pulumi.get(self, "rebind_localhost")

    @property
    @pulumi.getter(name="rebindProtection")
    def rebind_protection(self) -> bool:
        """
        Enables DNS rebind attack protection by discarding upstream RFC1918 responses.
        """
        return pulumi.get(self, "rebind_protection")

    @property
    @pulumi.getter
    def resolvfile(self) -> str:
        """
        Specifies an alternative resolv file.
        """
        return pulumi.get(self, "resolvfile")


class AwaitableGetDhcpDnsmasqResult(GetDhcpDnsmasqResult):
    # pylint: disable=using-constant-test
    def __await__(self):
        if False:
            yield self
        return GetDhcpDnsmasqResult(
            authoritative=self.authoritative,
            domain=self.domain,
            domainneeded=self.domainneeded,
            ednspacket_max=self.ednspacket_max,
            expandhosts=self.expandhosts,
            id=self.id,
            leasefile=self.leasefile,
            local=self.local,
            localise_queries=self.localise_queries,
            localservice=self.localservice,
            readethers=self.readethers,
            rebind_localhost=self.rebind_localhost,
            rebind_protection=self.rebind_protection,
            resolvfile=self.resolvfile)


def get_dhcp_dnsmasq(id: Optional[str] = None,
                     opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetDhcpDnsmasqResult:
    """
    A lightweight DHCP and caching DNS server.

    ## Example Usage

    ```python
    import pulumi
    import pulumi_openwrt as openwrt

    testing = openwrt.get_dhcp_dnsmasq(id="testing")
    ```


    :param str id: Name of the section. This name is only used when interacting with UCI directly.
    """
    __args__ = dict()
    __args__['id'] = id
    opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke('openwrt:index/getDhcpDnsmasq:getDhcpDnsmasq', __args__, opts=opts, typ=GetDhcpDnsmasqResult).value

    return AwaitableGetDhcpDnsmasqResult(
        authoritative=pulumi.get(__ret__, 'authoritative'),
        domain=pulumi.get(__ret__, 'domain'),
        domainneeded=pulumi.get(__ret__, 'domainneeded'),
        ednspacket_max=pulumi.get(__ret__, 'ednspacket_max'),
        expandhosts=pulumi.get(__ret__, 'expandhosts'),
        id=pulumi.get(__ret__, 'id'),
        leasefile=pulumi.get(__ret__, 'leasefile'),
        local=pulumi.get(__ret__, 'local'),
        localise_queries=pulumi.get(__ret__, 'localise_queries'),
        localservice=pulumi.get(__ret__, 'localservice'),
        readethers=pulumi.get(__ret__, 'readethers'),
        rebind_localhost=pulumi.get(__ret__, 'rebind_localhost'),
        rebind_protection=pulumi.get(__ret__, 'rebind_protection'),
        resolvfile=pulumi.get(__ret__, 'resolvfile'))


@_utilities.lift_output_func(get_dhcp_dnsmasq)
def get_dhcp_dnsmasq_output(id: Optional[pulumi.Input[str]] = None,
                            opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetDhcpDnsmasqResult]:
    """
    A lightweight DHCP and caching DNS server.

    ## Example Usage

    ```python
    import pulumi
    import pulumi_openwrt as openwrt

    testing = openwrt.get_dhcp_dnsmasq(id="testing")
    ```


    :param str id: Name of the section. This name is only used when interacting with UCI directly.
    """
    ...
